import Algorithms as algo;
import Operators as oper;
import Text as text;
import FileSystem as fs;
import Shell as shell;
import ShellCompletionTools as sct;

__apt_cache( context_ ) {
	contextSize = size( context_ );
	lastTerm = context_[-1];
	if ( contextSize < 3 ) {
		return ( sct.delimit_singular( sct.filter_by_prefix( [ "search", "show" ], lastTerm ) ) );
	}
	if ( context_[1] != "show" ) {
		return ( none );
	}
	cmd = context_[1];
	o = sct.file_cached( "apt-get-list-available", __apt_get_list_available, sct.is_up_to_date( ~, "/var/lib/apt" ) );
	completions = sct.delimit_singular( sct.filter_by_prefix( o, lastTerm ) );
	return ( completions );
}

__apt_get_list_available() {
	return ( shell.command_output( "apt-cache", ["pkgnames"] ) );
}

__apt_file( context_ ) {
	baseCmds = [ "search", "update" ];
	if ( size( context_ ) < 3 ) {
		return ( sct.delimit_singular( sct.filter_by_prefix( baseCmds, context_[-1] ) ) );
	}
	return ( none );
}

__apt_get( context_ ) {
	contextSize = size( context_ );
	lastTerm = context_[-1];
	baseCmds = [ "autoclean", "autoremove", "install", "purge", "remove", "update", "upgrade", "dist-upgrade", "source" ];
	if ( contextSize < 3 ) {
		return ( sct.delimit_singular( sct.filter_by_prefix( baseCmds, lastTerm ) ) );
	}
	cmd = context_[1];
	completions = [];
	if ( ( cmd == "remove" ) || ( cmd == "purge" ) ) {
		o = shell.command_output( "dpkg-query", [ "-W", "-f", "${Package}\\n" ] );
		completions = sct.delimit_singular( sct.filter_by_prefix( o, lastTerm ) );
	} else if ( ( cmd == "install" ) || ( cmd == "source" ) ) {
		o = sct.file_cached( "apt-get-list-available", __apt_get_list_available, sct.is_up_to_date( ~, "/var/lib/apt" ) );
		completions = sct.delimit_singular( sct.filter_by_prefix( o, lastTerm ) );
	}
	options = none;
	if ( cmd == "install" ) {
		options = ["--fix-broken", "--ignore-missing", "--yes", "--reinstall", "--mark-auto", "--no-install-recommends", "--install-suggests"];
	} else if ( cmd == "update" ) {
		options = ["--allow-releaseinfo-change", "--yes"];
	} else if ( cmd == "dist-upgrade" ) {
		options = ["--allow-releaseinfo-change", "--ignore-missing", "--yes"];
	}
	if ( options != none ) {
		completions = sct.delimit_singular( sct.filter_by_prefix( options, lastTerm ) ) + completions;
	}
	return ( completions );
}

__bindkey( context_ ) {
	options = [ "--internal", "--system" ];
	contextSize = size( context_ );
	lastTerm = context_[-1];
	if ( contextSize == 2 ) {
		return ( sct.delimit_singular( sct.filter_by_prefix( options, lastTerm ) ) );
	}
	return ( none );
}

__brew( context_ ) {
	contextSize = size( context_ );
	lastTerm = context_[-1];
	baseCmds = [ "search", "info", "install", "update", "upgrade", "uninstall", "list", "tap", "untap", "home", "formulae", "help" ];
	if ( contextSize < 3 ) {
		return ( sct.delimit_singular( sct.filter_by_prefix( baseCmds, lastTerm ) ) );
	}
	cmd = context_[1];
	if ( ( cmd == "uninstall" ) || ( cmd == "list" ) ) {
		o = shell.command_output( "brew", [ "list", "--formula" ] );
		completions = sct.delimit_singular( sct.filter_by_prefix( o, lastTerm ) );
		return ( completions );
	} else if ( ( cmd == "install" ) || ( cmd == "info" ) ) {
		o = shell.command_output( "brew", ["formulae"] );
		completions = sct.delimit_singular( sct.filter_by_prefix( o, lastTerm ) );
		return ( completions );
	}
	return ( none );
}

__cd( context_ ) {
	return ( "dirs" );
}

__chown( context_ ) {
	contextSize = size( context_ );
	lastTerm = context_[-1];
	if ( ( contextSize > 2 ) && ( context_[1] == "-R" ) ) {
		contextSize -= 1;
	}
	if ( contextSize > 2 ) {
		return ( "files" );
	}
	by = ":";
	source = sct.get_users;
	colonIdx = lastTerm.find( ":" );
	pfx = "";
	if ( colonIdx >= 0 ) {
		pfx = lastTerm[:colonIdx + 1];
		lastTerm = lastTerm[colonIdx + 1:];
		by = " ";
		source = sct.get_groups;
	}
	completions = sct.delimit_singular( algo.materialize( algo.map( sct.filter_by_prefix( source(), lastTerm ), oper.add( pfx, ~ ) ), list ), by );
	return ( completions );
}

__cp( context_ ) {
	return ( "files" );
}

__dd( context_ ) {
	options = { "if=", "of=", "bs=", "count=", "status=", "conv=", "seek=", "skip=", "oflag=", "iflag=" };
	contextSize = size( context_ );
	if ( contextSize <= 1 ) {
		return ( algo.materialize( options, list ) );
	}
	lastTerm = context_[-1];
	option = lastTerm[:lastTerm.find( "=" ) + 1];
	idx = lastTerm.find_last_one_of( "=," ) + 1;
	if ( ( option == "if=" ) || ( option == "of=" ) ) {
		return ( "prefix:files:" + lastTerm[3:] );
	} else if ( option == "conv=" ) {
		options = [ "notrunc", "sparse", "fdatasync", "fsync" ];
	} else if ( ( option == "iflag=" ) || ( option == "oflag=" ) ) {
		options = [ "append", "direct", "dsync", "sync", "fullblock", "nonblock", "nocache", "noctty" ];
	} else if ( option == "status=" ) {
		options = ["progress"];
	} else if ( option ∈ options ) {
		return ( none );
	}
	if ( type( options ) == list ) {
		optLen = size( option );
		options = algo.map( options, oper.add( lastTerm[optLen:idx], ~ ) );
		lastTerm = lastTerm[optLen:];
	}
	return ( sct.filter_by_prefix( options, lastTerm ) );
}

__dirs( context_ ) {
	options = [ "--no-index", "--escape", "--help" ];
	lastTerm = "";
	if ( size( context_ ) > 1 ) {
		lastTerm = context_[-1];
	}
	return ( sct.delimit_singular( sct.filter_by_prefix( options, lastTerm ) ) );
}

__dnf_list_available() {
	o = shell.command_output( "sudo", [ "dnf", "--cacheonly", "list", "-x", "*.i686", "--available" ] );
	o = algo.map( o, @( x ) { text.split( x )[0]; } );
	o = algo.map( o, @( x ) { if ( x.ends_with( ".x86_64" ) || x.ends_with( ".noarch" ) ) { x = x[:-7]; } x; } );
	return ( o );
}

__dnf( context_ ) {
	contextSize = size( context_ );
	lastTerm = context_[-1];
	baseCmds = [
		"autoremove", "check-update", "clean", "deplist", "distro-sync", "help",
		"info", "install", "list", "provides", "reinstall", "remove", "search",
		"updateinfo", "upgrade", "makecache"
	];
	if ( contextSize < 3 ) {
		return ( sct.delimit_singular( sct.filter_by_prefix( baseCmds, lastTerm ) ) );
	}
	cmd = context_[1];
	if ( ( cmd == "remove" ) || ( cmd == "reinstall" ) ) {
		o = shell.command_output( "rpm", ["-qa"] );
		completions = sct.delimit_singular( sct.filter_by_prefix( o, lastTerm ) );
		return ( completions );
	} else if ( ( cmd == "install" ) || ( cmd == "info" ) ) {
		o = sct.file_cached( "dnf-list-available", __dnf_list_available, sct.is_up_to_date( ~, [ "/var/lib/rpm/rpmdb.sqlite", "/var/lib/rpm/Packages" ] ) );
		completions = sct.delimit_singular( sct.filter_by_prefix( o, lastTerm ) );
		return ( completions );
	}
	return ( none );
}

__docker_image( context_ ) {
	cmds = [ "build", "history", "import", "inspect", "load", "ls", "prune", "pull", "push", "rm", "save", "tag" ];
	contextSize = size( context_ );
	if ( contextSize < 1 ) {
		return ( cmds );
	}
	lastTerm = context_[-1];
	if ( contextSize < 2 ) {
		return ( sct.delimit_singular( sct.filter_by_prefix( cmds, lastTerm ) ) );
	}
	cmd = context_[0];
	completions = none;
	switch ( cmd ) {
		case ( "rm" ): {
			o = shell.command_output( "docker", [ "image", "ls", "--format", "{{.Repository}}:{{.Tag}}" ] );
			completions = sct.delimit_singular( sct.filter_by_prefix( o, lastTerm ) );
		} break;
	}
	return ( completions );
}

__docker_container( context_ ) {
	cmds = [
		"attach", "commit", "cp", "create", "diff", "exec", "export", "inspect", "kill", "logs", "ls",
		"pause", "port", "prune", "rename", "restart", "rm", "run", "start", "stats", "stop", "top",
		"unpause", "update", "wait"
	];
	contextSize = size( context_ );
	if ( contextSize < 1 ) {
		return ( cmds );
	}
	lastTerm = context_[-1];
	if ( contextSize < 2 ) {
		return ( sct.delimit_singular( sct.filter_by_prefix( cmds, lastTerm ) ) );
	}
	command = context_[0];
	if ( command ∈ ( "attach", "inspect", "kill", "restart", "start", "stop", "stats", "top", "cp", "rename" ) ) {
		o = shell.command_output( "docker", [ "container", "ls", "--all", "--format", "{{.Names}}" ] );
		return ( sct.delimit_singular( sct.filter_by_prefix( o, lastTerm ) ) );
	}
	return ( none );
}

__docker( context_ ) {
	baseCmds = [
		"attach", "build", "commit", "config", "container", "cp", "create", "diff", "events", "exec", "export",
		"history", "image", "images", "import", "info", "inspect", "kill", "load", "login", "logout", "logs",
		"network", "node", "pause", "plugin", "port", "ps", "pull", "push", "rename", "restart", "rm", "rmi",
		"run", "save", "search", "secret", "service", "stack", "start", "stats", "stop", "swarm", "system",
		"tag", "top", "trust", "unpause", "update", "version", "volume", "wait"
	];
	contextSize = size( context_ );
	lastTerm = context_[-1];
	if ( contextSize < 2 ) {
		return ( baseCmds );
	}
	if ( contextSize < 3 ) {
		return ( sct.delimit_singular( sct.filter_by_prefix( baseCmds, lastTerm ) ) );
	}
	subCommandCompletions = {
		"image": __docker_image,
		"container": __docker_container
	};
	subCmd = context_[1];
	if ( subCmd ∉ subCommandCompletions ) {
		return ( none );
	}
	return ( subCommandCompletions[subCmd]( context_[2:] ) );
}

__dpkg( context_ ) {
	switches = [ "-L", "-S", "-l", "-P", "-s" ];
	contextSize = size( context_ );
	if ( contextSize <= 1 ) {
		return ( switches );
	}
	lastTerm = context_[-1];
	if ( contextSize < 2 ) {
		return ( sct.delimit_singular( sct.filter_by_prefix( switches, lastTerm ) ) );
	}
	contextTerm = context_[-2];
	completions = [];
	switch ( contextTerm ) {
		case ( "-S" ): {
			completions = "files";
		} break;
		case ( "-P" ): { /* fall-through */ }
		case ( "-L" ): {
			o = shell.command_output( "dpkg-query", [ "-W", "-f", "${Package}\\n" ] );
			completions = sct.delimit_singular( sct.filter_by_prefix( o, lastTerm ) );
		} break;
		case ( "-l" ): {
			if ( context_[-1] == "" ) {
				completions = ["'**'"];
			}
		} break;
		case ( "-s" ): {
			o = sct.file_cached( "apt-get-list-available", __apt_get_list_available, sct.is_up_to_date( ~, "/var/lib/apt" ) );
			completions = sct.delimit_singular( sct.filter_by_prefix( o, lastTerm ) );
		} break;
		case ( "-i" ): {
			completions = "files:[.]deb$";
		} break;
		default: {
			completions += sct.delimit_singular( sct.filter_by_prefix( switches, lastTerm ) );
		}
	}
	return ( completions );
}

__dpkg_reconfigure( context_ ) {
	o = shell.command_output( "dpkg-query", [ "-W", "-f", "${Package}\\n" ] );
	completions = sct.delimit_singular( sct.filter_by_prefix( o, context_[-1] ) );
	return ( completions );
}

__env( context_ ) {
	contextSize = size( context_ ) - 1;
	i = 1;
	while ( i < contextSize ) {
		token = context_[i];
		if ( token == "-u" ) {
			i += 2;
			continue;
		}
		if ( ( size( token ) > 0 ) && ( token.find( "=" ) < 0 ) ) {
			break;
		}
		i += 1;
	}
	completions = ( i < contextSize )
		? sct.complete( context_[i:] )
		: (
			( context_[-2] == "-u" )
				? "environment"
				: ( "environment", "executables: " )
		);
	return ( completions );
}

__exec( context_ ) {
	if ( size( context_ ) <= 2 ) {
		return ( "executables: " );
	}
	return ( sct.forward( context_ ) );
}

__file( context_ ) {
	return ( "files" );
}

__find( context_ ) {
	contextSize = size( context_ );
	if ( contextSize < 3 ) {
		return ( "dirs" );
	}
	lastSwitch = context_[-2];
	lastTerm = context_[-1];
	completions = sct.delimit_singular( sct.filter_by_prefix( [ "-name", "-iname", "-path", "-print0", "-perm" ], context_[-1] ) );
	if ( ( lastTerm == "" ) && ( ( lastSwitch == "-name" ) || ( lastSwitch == "-iname" ) || ( lastSwitch == "-path" ) ) ) {
		completions = ["'**'"];
	} else if ( ( size( completions ) == 1 ) && ( ( completions[0] == "-iname " ) || ( completions[0] == "-name " ) || ( completions[0] == "-path " ) ) ) {
		completions[0] += "'**'";
	}
	return ( completions );
}

__getent( context_ ) {
	contextSize = size( context_ );
	lastTerm = context_[-1];
	colonSeparated = [ "aliases", "group", "passwd" ];
	spaceSeparated = [ "protocols", "rpc", "services", "networks" ];
	hosts = [ "ahosts", "hosts" ];
	other = hosts + [ "ethers", "initgroups" ];
	baseCmds = colonSeparated + spaceSeparated + other;
	if ( contextSize < 3 ) {
		return ( sct.delimit_singular( sct.filter_by_prefix( baseCmds, lastTerm ) ) );
	}
	cmd = context_[1];
	if ( cmd ∉ other ) {
		separator = cmd ∈ colonSeparated ? ":" : " ";
		o = shell.command_output( "getent", [cmd] );
		completions = sct.delimit_singular( sct.filter_by_prefix( algo.map( o, @[separator]( x ) { text.split( x, separator )[0]; } ), lastTerm ) );
		return ( completions );
	} else if ( cmd ∈ hosts ) {
		o = shell.command_output( "getent", [cmd] );
		completions = sct.delimit_singular( sct.filter_by_prefix( sct.split( o ), lastTerm ) );
		return ( completions );
	}
	return ( none );
}

__git_get_branches( lastTerm_ ) {
	o = shell.command_output( "git", [ "branch", "-a" ] );
	return ( sct.delimit_singular( sct.filter_by_prefix_with_delim( sct.drop_str( sct.drop( sct.split( o ), [ "*", "->" ] ), ["remotes/"] ), lastTerm_, "/" ) ) );
}

__git( context_ ) {
	baseCmds = [
		"add", "apply", "archive", "bisect", "blame", "branch", "checkout", "cherry-pick", "clone", "commit", "config",
		"diff", "difftool", "fetch", "grep", "help", "init", "log", "ls-files", "merge", "mergetool", "mv", "prune", "pull",
		"push", "rebase", "reflog", "remote", "reset", "revert", "rm", "show", "show-branch", "stash", "status", "submodule", "tag"
	];
	baseCmds += algo.materialize( algo.map( shell.command_output( "git", [ "config", "--name-only", "--get-regexp", "alias" ] ), @( x ) { x[6:]; } ), list );
	baseFlags = [ "-c", "-C", "--bare" ];
	contextSize = size( context_ );
	if ( contextSize <= 1 ) {
		return ( baseCmds );
	}
	lastTerm = context_[-1];
	completions = [];
	if (
		( contextSize == 2 )
		|| ( ( contextSize >= 3 ) && ( context_[-2] == "--bare" ) )
		|| ( ( contextSize >= 4 ) && ( ( context_[-3] == "-C" ) || ( context_[-3] == "-c" ) ) )
	) {
		return ( sct.delimit_singular( sct.filter_by_prefix( algo.chain( baseCmds, baseFlags ), lastTerm ) ) );
	}
	contextTerm = context_[-2];
	i = 1;
	while ( i < contextSize ) {
		token = context_[i];
		if ( token == "--bare" ) {
		} else if ( ( i < contextSize ) && ( ( token == "-C" ) || ( token == "-c" ) ) ) {
			i += 1;
		} else {
			contextTerm = token;
			break;
		}
		i += 1;
	}
	flagTermIdx = -2;
	flagTerm = context_[flagTermIdx];
	if ( ! flagTerm.starts_with( "-" ) && ( contextSize > 3 ) && context_[-3].starts_with( "-" ) ) {
		flagTermIdx = -3;
		flagTerm = context_[flagTermIdx];
	}
	//print( "\ncontext: [{}]\ncontextSize = [{}]\ncontextTerm = [{}]\nflagTerm = [{}]\nlastTerm = [{}]\n".format( context_, contextSize, contextTerm, flagTerm, lastTerm ) );
	delimitSingular = " ";
	switch ( contextTerm ) {
		case ( "help" ): {
			completions = sct.delimit_singular( sct.filter_by_prefix( baseCmds, lastTerm ) );
		} break;
		case ( "add" ): {
			o = shell.command_output( "git", [ "ls-files", "--exclude-standard", "-o", "-m" ] );
			completions = sct.delimit_singular( sct.filter_by_prefix_with_delim( o, lastTerm, "/" ) );
		} break;
		case ( "branch" ): {
			if ( flagTerm ∈ ( "--delete", "-D", "-rD", "-d", "-rd", "--move", "--copy" ) ) {
				completions += __git_get_branches( lastTerm );
			} else {
				branchFlags = [ "--all", "--remotes", "--delete", "-D", "-rD", "--move", "--copy", "-avv", "--verbose", "--track", "--no-track", "--set-upstream", "--force" ];
				completions += sct.delimit_singular( sct.filter_by_prefix( branchFlags, lastTerm ) );
			}
		} break;
		case ( "checkout" ): {
			if ( ( flagTerm != "-b" ) && ( flagTerm != "-B" ) ) {
				checkoutFlags = [ "-b", "-B", "--force", "--track", "--no-track" ];
				completions = sct.delimit_singular( sct.filter_by_prefix( checkoutFlags, lastTerm ) );
				completions += __git_get_branches( lastTerm );
				o = shell.command_output( "git", ["tag"] );
				completions += sct.delimit_singular( sct.filter_by_prefix_with_delim( o, lastTerm, "/" ) );
				o = shell.command_output( "git", [ "ls-files", "-m" ] );
				completions += sct.delimit_singular( sct.filter_by_prefix_with_delim( o, lastTerm, "/" ) );
			} else if ( contextSize > 4 ) {
				completions = __git_get_branches( lastTerm );
			}
		} break;
		case ( "cherry-pick" ): {
			cherrypickFlags = [ "--abort", "--continue", "--edit", "--no-commit", "--quit" ];
			completions = sct.delimit_singular( sct.filter_by_prefix( cherrypickFlags, lastTerm ) );
			completions += __git_get_branches( lastTerm );
		} break;
		case ( "-C" ): {
			return ( "dirs" );
		}
		case ( "commit" ): {
			if ( lastTerm == "-m" ) {
				completions = ["-m ''"];
			} else if ( ( flagTerm == "-m" ) && ( flagTermIdx == -2 ) ) {
				completions = ["''"];
			} else {
				commitFlags = [ "--amend", "-a", "--no-edit", "-m", "-p" ];
				completions = sct.delimit_singular( sct.filter_by_prefix( commitFlags, lastTerm ) );
				o = shell.command_output( "git", [ "ls-files", "--exclude-standard", "-o", "-m" ] );
				completions += sct.delimit_singular( sct.filter_by_prefix_with_delim( o, lastTerm, "/" ) );
			}
		} break;
		case ( "-c" ): { delimitSingular = "="; }
		case ( "config" ): {
			o = shell.command_output( "git", [ "config", "-l", "--name-only" ] );
			completions = sct.delimit_singular( sct.filter_by_prefix( o, lastTerm ), delimitSingular );
		} break;
		case ( "diff" ): {
			diffFlags = [ "--color-words", "--cached" ];
			completions = sct.delimit_singular( sct.filter_by_prefix( diffFlags, lastTerm ) );
		} break;
		case ( "difftool" ): {
			if ( ( flagTerm == "-t" ) && ( flagTermIdx == -2 ) ) {
				completions = ["meld "];
			} else {
				difftoolFlags = [ "-d", "-t" ];
				completions = sct.delimit_singular( sct.filter_by_prefix( difftoolFlags, lastTerm ) ) + __git_get_branches( lastTerm );
			}
		} break;
		case ( "fetch" ): {
			fetchFlags = [ "--all", "--prune", "--prune-tags", "--no-tags", "--tags" ];
			completions = sct.delimit_singular( sct.filter_by_prefix( fetchFlags, lastTerm ) );
			o = shell.command_output( "git", ["remote"] );
			completions += sct.delimit_singular( sct.filter_by_prefix( o, lastTerm ) );
		} break;
		case ( "log" ): {
			logFlags = [ "--oneline", "--pretty" ];
			completions = sct.delimit_singular( sct.filter_by_prefix( logFlags, lastTerm ) );
			logFlags = [ "--format=email", "--format=short", "--format=medium", "--format=fuller", "--date=iso", "--date=rfc", "--date=unix" ];
			completions += sct.delimit_singular( sct.filter_by_prefix_with_delim( logFlags, lastTerm, "=" ) );
		} break;
		case ( "merge" ): {
			mergeFlags = [ "--abort", "--continue", "--quit", "--ff" ];
			completions = sct.delimit_singular( sct.filter_by_prefix( mergeFlags, lastTerm ) );
			completions += __git_get_branches( lastTerm );
		} break;
		case ( "pull" ): {
			pullFlags = [ "--all", "--rebase", "--tags" ];
			completions = sct.delimit_singular( sct.filter_by_prefix( pullFlags, lastTerm ) );
			completions += __git_get_branches( lastTerm );
			o = shell.command_output( "git", ["remote"] );
			completions += sct.delimit_singular( sct.filter_by_prefix( sct.split( o ), lastTerm ) );
		} break;
		case ( "push" ): {
			pushFlags = [ "--all", "--prune", "--mirror", "--tags", "--delete", "--force", "--set-upstream" ];
			completions = sct.delimit_singular( sct.filter_by_prefix( pushFlags, lastTerm ) );
			completions += __git_get_branches( lastTerm );
		} break;
		case ( "rebase" ): {
			rebaseFlags = [ "--abort", "--continue", "--interactive", "--skip" ];
			completions = sct.delimit_singular( sct.filter_by_prefix( rebaseFlags, lastTerm ) );
			completions += __git_get_branches( lastTerm );
		} break;
		case ( "remote" ): {
			remoteCommands = [ "-v", "add", "rename", "rm", "prune", "set-head", "set-branch", "set-url" ];
			completions = sct.delimit_singular( sct.filter_by_prefix( remoteCommands, lastTerm ) );
		} break;
		case ( "reset" ): {
			resetFlags = [ "--hard ", "--soft ", "--keep ", "--mixed ", "--merge ", "HEAD~" ];
			completions = sct.delimit_singular( sct.filter_by_prefix( resetFlags, lastTerm ), "" );
			completions += __git_get_branches( lastTerm );
		} break;
		case ( "stash" ): {
			stashCommands = [ "list", "show", "sct.drop", "pop", "apply", "branch", "save", "clear", "create" ];
			completions = sct.delimit_singular( sct.filter_by_prefix( stashCommands, lastTerm ) );
		} break;
		case ( "status" ): {
			statusFlags = [ "--branch", "--ignored", "--long", "--porcelain", "--short" ];
			completions = sct.delimit_singular( sct.filter_by_prefix( statusFlags, lastTerm ) );
		} break;
		case ( "submodule" ): {
			stashCommands = [ "add", "status", "init", "deinit", "update", "set-branch", "set-url", "summary", "foreach", "sync", "absorbgitdirs" ];
			completions = sct.delimit_singular( sct.filter_by_prefix( stashCommands, lastTerm ) );
		} break;
		case ( "tag" ): {
			if ( ( flagTerm == "--delete" ) || ( flagTerm == "-d" ) ) {
				o = shell.command_output( "git", [ "tag", "--list" ] );
				completions += sct.delimit_singular( sct.filter_by_prefix_with_delim( o, lastTerm, "/" ) );
			} else if ( ( flagTerm == "--file" ) || ( flagTerm == "-F" ) ) {
				completions = "files";
			} else if ( lastTerm == "-m" ) {
				completions = ["-m ''"];
			} else if ( flagTerm == "-m" ) {
				completions = ["''"];
			} else {
				tagFlags = [ "--delete", "-d", "-a", "--force", "--list", "--file" ];
				completions += sct.delimit_singular( sct.filter_by_prefix( tagFlags, lastTerm ) );
			}
		} break;
		default: {
			return ( "files" );
		}
	}
	//print( "[[[\n{}\n]]]\n".format( completions ) );
	return ( completions );
}

__gpg( context_ ) {
	switches = [
		"--armor", "--bzip2-compress-level", "--card-edit", "--card-status", "--change-pin", "--check-sigs",
		"--check-trustdb", "--clearsign", "--compress-level", "--dearmor", "--decrypt", "--decrypt-files",
		"--delete-key", "--delete-secret-and-public-key", "--delete-secret-key", "--desig-revoke",
		"--detach-sign", "--dump-options", "--edit-key", "--enarmor", "--encrypt", "--encrypt-files", "--expert",
		"--export", "--export-options", "--export-ownertrust", "--export-secret-keys", "--export-secret-subkeys",
		"--fast-import", "--fetch-keys", "--full-generate-key", "--fingerprint", "--gen-key", "--gen-prime",
		"--gen-random", "--gen-revoke", "--homedir", "--import", "--import-options", "--import-ownertrust",
		"--interactive", "--keyring", "--keyserver-options", "--list-keys", "--list-packets", "--list-public-keys",
		"--list-secret-keys", "--list-sigs", "--lsign-key", "--multifile", "--no-armor", "--no-textmode", "--output",
		"--primary-keyring", "--print-md", "--print-mds", "--rebuild-keydb-caches", "--recv-keys", "--refresh-keys",
		"--search-keys", "--secret-keyring", "--send-keys", "--sign", "--sign-key", "--symmetric", "--textmode",
		"--trustdb-name", "--update-trustdb", "--verify", "--verify-files", "--with-fingerprint", "--with-keygrip"
	];
	lastTerm = "";
	contextSize = size( context_ );
	if ( contextSize <= 1 ) {
		return ( switches );
	}
	lastTerm = context_[-1];
	if ( contextSize < 2 ) {
		return ( sct.delimit_singular( sct.filter_by_prefix( switches, lastTerm ) ) );
	}
	contextTerm = context_[-2];
	completions = [];
	switch ( contextTerm ) {
		case ( "--import-options" ): {
			importOptions = [ "import-local-sigs", "merge-only", "import-clean", "import-minimal" ];
			completions += sct.delimit_singular( sct.filter_by_prefix( importOptions, lastTerm ) );
		} break;
		case ( "--export-options" ): {
			exportOptions = [ "export-local-sigs", "export-attributes", "export-sensitive-revkeys", "export-reset-subkey-passwd", "export-clean export-minimal" ];
			completions += sct.delimit_singular( sct.filter_by_prefix( exportOptions, lastTerm ) );
		} break;
		case ( "--export" ): { /* fall-through */ }
		case ( "--edit-key" ): { /* fall-through */ }
		case ( "--send-keys" ): {
			o = shell.command_output( "gpg", ["-k"] );
			completions += sct.delimit_singular(
				sct.filter_by_prefix_with_delim(
					algo.map( shell.grep( o, "uid.*@" ), @( x ) { text.split( x )[-1].strip( "<>" ); } ),
					lastTerm,
					"@"
				)
			);
		} break;
		case ( "--import" ): { /* fall-through */ }
		case ( "-s" ): { /* fall-through */ }
		case ( "--sign" ): { /* fall-through */ }
		case ( "--cleersign" ): { /* fall-through */ }
		case ( "--cleer-sign" ): { /* fall-through */ }
		case ( "--detach-sign" ): { /* fall-through */ }
		case ( "-c" ): { /* fall-through */ }
		case ( "--symmetric" ): { /* fall-through */ }
		case ( "--decrypt" ): {
			completions = "files";
		} break;
		case ( "--homedir" ): {
			completions = "dirs";
		} break;
		default: {
			completions += sct.delimit_singular( sct.filter_by_prefix( switches, lastTerm ) );
		}
	}
	return ( completions );
}

__help( context_ ) {
	topics = [
		"alias", "bg", "bindkey", "call", "cd", "dirs", "eval", "exec", "exit",
		"fg", "help", "history", "jobs", "rehash", "setenv", "setopt",
		"source", "unalias", "unsetenv", "topics", "history_path", "history_max_size",
		"ignore_filenames", "super_user_paths", "trace", "prefix_commands"
	];
	lastTerm = "";
	if ( size( context_ ) > 1 ) {
		lastTerm = context_[-1];
	}
	return ( sct.delimit_singular( sct.filter_by_prefix( topics, lastTerm ) ) );
}

__history( context_ ) {
	options = [ "--indexed", "--timestamps", "--no-color", "--help" ];
	lastTerm = "";
	if ( size( context_ ) > 1 ) {
		lastTerm = context_[-1];
	}
	return ( sct.delimit_singular( sct.filter_by_prefix( options, lastTerm ) ) );
}

__hgnsh( context_ ) {
	return ( __huginn( context_ ) );
}

__huginn( context_ ) {
	options = [
		"--auto-split",
		"--alias-imports",
		"--assume-used",
		"--be-sloppy",
		"--color-scheme",
		"--command",
		"--dump-state",
		"--embedded",
		"--field-separator",
		"--gen-docs",
		"--help",
		"--history-file",
		"--in-place",
		"--jupyter",
		"--chomp",
		"--lint",
		"--log-path",
		"--module-path",
		"--sed-n",
		"--native-lines",
		"--no-argv",
		"--no-color",
		"--no-default-imports",
		"--no-default-init",
		"--optimize",
		"--sed",
		"--quiet",
		"--rapid-start",
		"--reformat",
		"--shell",
		"--session",
		"--session-directory",
		"--tags",
		"--timeit",
		"--verbose",
		"--version",
		"--dump-configuration"
	];
	lastTerm = "";
	if ( size( context_ ) > 1 ) {
		lastTerm = context_[-1];
	}
	return ( ( sct.delimit_singular( sct.filter_by_prefix( options, lastTerm ) ), "files:[.]hgn$" ) );
}

__ip( context_ ) {
	contextSize = size( context_ );
	lastTerm = context_[-1];
	baseCmds = [ "link", "address", "route", "neigh" ];
	if ( contextSize < 3 ) {
		return ( sct.delimit_singular( sct.filter_by_prefix( baseCmds, lastTerm ) ) );
	}
	cmd = context_[1];
	if ( contextSize < 4 ) {
		subCmds = none;
		switch ( cmd ) {
			case ( "address" ): {
				subCmds = [ "add", "change", "replace", "del", "show", "help" ];
			} break;
			case ( "link" ): {
				subCmds = [ "add", "delete", "set", "show", "help" ];
			} break;
			case ( "neigh" ): {
				subCmds = [ "add", "del", "change", "replace", "show", "flush", "help" ];
			} break;
			case ( "route" ): {
				subCmds = [ "list", "flush", "add", "del", "change", "append", "replace", "help" ];
			} break;
		}
		if ( subCmds != none ) {
			return ( sct.delimit_singular( sct.filter_by_prefix( subCmds, lastTerm ) ) );
		}
	}
	subCmd = context_[2];
	get_interfaces = @[lastTerm]() {
		o = shell.command_output( "ip", [ "link", "show" ] );
		ifaces = [];
		for ( i, line : algo.enumerate( o ) ) {
			if ( i % 2 == 1 ) {
				continue;
			}
			ifaces.push( text.split( line )[1][:-1] );
		}
		return ( sct.delimit_singular( sct.filter_by_prefix( ifaces, lastTerm ) ) );
	};
	get_ips = @[lastTerm]() {
		o = shell.command_output( "ip", [ "address", "show" ] );
		algo.materialize( shell.awk( o, "\\binet\\b", 2 ), list );
	};
	switch ( cmd ) {
		case ( "address" ): {
			if ( ( contextSize == 4 ) && ( subCmd == "del" ) ) {
				return ( get_ips() );
			} else if ( ( ( contextSize == 5 ) && ( subCmd != "show" ) ) || ( ( contextSize == 4 ) && ( subCmd == "show" ) ) ) {
				return ( ["dev "] );
			} else if ( ( ( contextSize == 6 ) && ( subCmd != "show" ) ) || ( ( contextSize == 5 ) && ( subCmd == "show" ) ) ) {
				return ( get_interfaces() );
			} else if ( contextSize == 7 ) {
				return ( ["label "] );
			}
		} break;
		case ( "link" ): {
		} break;
		case ( "neigh" ): {
		} break;
		case ( "route" ): {
			if ( contextSize == 5 ) {
				return ( ["via "] );
			} else if ( contextSize == 7 ) {
				return ( ["dev "] );
			} else if ( contextSize == 8 ) {
				return ( get_interfaces() );
			} else if ( contextSize == 4 ) {
				return ( ["default "] );
			}
		} break;
	}
	return ( none );
}

__make( context_ ) {
	makefileNames = [ "BSDmakefile", "GNUmakefile", "Makefile", "makefile", "_aux/mk/master.mk" ];
	contextSize = size( context_ );
	lastTerm = context_[-1];
	contextTerm = "";
	if ( contextSize > 2 ) {
		contextTerm = context_[-2];
	}
	if ( contextTerm == "-f" ) {
		return ( "files" );
	}
	if ( contextTerm == "-C" ) {
		return ( "dirs" );
	}
	makefileDir = "./";
	makefileDirOpt = false;
	makefileOpt = false;
	for ( tok : context_ ) {
		if ( tok == "-C" ) {
			makefileDirOpt = true;
			continue;
		}
		if ( tok == "-f" ) {
			makefileOpt = true;
			continue;
		}
		if ( makefileDirOpt ) {
			makefileDir = tok;
		}
		if ( makefileOpt ) {
			makefileNames = [tok];
		}
		makefileDirOpt = false;
		makefileOpt = false;
	}
	completions = [];
	for ( makefileName : algo.map( makefileNames, oper.add( makefileDir, ~ ) ) ) {
		try {
			makefile = fs.open( makefileName, fs.OPEN_MODE.READ );
			completions += sct.delimit_singular( sct.filter_by_prefix( sct.drop( sct.split( algo.filter( makefile, @( l ) { l.find( "PHONY" ) >= 0; } ) ), [".PHONY:"] ), lastTerm ) );
		} catch ( FileSystemException e ) {
		}
	}
	if ( ( lastTerm == "" ) || ( lastTerm == "-" ) ) {
		completions.push( "-f" ).push( "-C" );
	} else if ( lastTerm == "-f" ) {
		completions.push( "-f " );
	} else if ( lastTerm == "-C" ) {
		completions.push( "-C " );
	}
	return ( completions );
}

__man( context_ ) {
	return ( ( "commands: ", "su-commands: " ) );
}

__mv( context_ ) {
	contextSize = size( context_ );
	return ( contextSize > 3 ? "dirs" : "files" );
}

__nice( context_ ) {
	contextSize = size( context_ );
	if ( contextSize <= 2 ) {
		return ( ["-19 "] );
	}
	if ( contextSize <= 3 ) {
		return ( "executables: " );
	}
	return ( sct.forward( context_ ) );
}

__pip( context_ ) {
	return ( __pip3( context_ ) );
}

__pip3( context_ ) {
	baseCmds = [
		"install", "download", "uninstall", "freeze", "list",
		"show", "check", "config", "search", "wheel", "hash", "help"
	];
	contextSize = size( context_ );
	lastTerm = context_[-1];
	if ( contextSize < 3 ) {
		return ( sct.delimit_singular( sct.filter_by_prefix( baseCmds, lastTerm ) ) );
	}
	if ( ( context_[1] == "uninstall" ) || ( context_[1] == "show" ) ) {
		o = shell.command_output( "pip3", [ "list", "--no-color", "--format", "freeze" ] );
		o = algo.map( o, @( x ) { text.split( x, "=" )[0]; } );
		completions = sct.delimit_singular( sct.filter_by_prefix( o, lastTerm ) );
		return ( completions );
	}
	return ( none );
}

__pkg_list_available() {
	o = shell.command_output( "/usr/sbin/pkg", [ "search", "." ] );
	o = algo.map( o, @( x ) { text.split( x )[0]; } );
	return ( o );
}

__pkg( context_ ) {
	contextSize = size( context_ );
	lastTerm = context_[-1];
	baseCmds = [
		"add", "autoremove", "check", "clean", "delete", "fetch",
		"help", "info", "install", "query", "remove", "rquery",
		"search", "update", "updating", "upgrade", "which"
	];
	if ( contextSize < 3 ) {
		return ( sct.delimit_singular( sct.filter_by_prefix( baseCmds, lastTerm ) ) );
	}
	cmd = context_[1];
	if ( ( cmd == "delete" ) || ( cmd == "remove" ) ) {
		o = shell.command_output( "/usr/sbin/pkg", [ "info", "-a" ] );
		completions = sct.delimit_singular( sct.filter_by_prefix( algo.map( o, @( x ) { text.split( x )[0]; } ), lastTerm ) );
		return ( completions );
	} else if ( ( cmd == "install" ) || ( cmd == "info" ) ) {
		o = sct.file_cached( "pkg-list-available", __pkg_list_available, sct.is_up_to_date( ~, "/var/db/pkg/FreeBSD.meta" ) );
		completions = sct.delimit_singular( sct.filter_by_prefix( o, lastTerm ) );
		return ( completions );
	} else if ( ( cmd == "add" ) || ( cmd == "which" ) ) {
		return ( "files" );
	} else if ( ( cmd == "rquery" ) && ( contextSize < 4 ) ) {
		return ( ["'Name: %n\\nSize: %sh\\nDescription:\\n%e' "] );
	}
	return ( none );
}

__pkill( context_ ) {
	contextSize = size( context_ );
	lastTerm = "";
	if ( contextSize > 1 ) {
		lastTerm = context_[-1];
	}
	o = shell.command_output( "ps", [ "hx", "-o", "args" ] );
	completions = sct.delimit_singular( sct.filter_by_prefix( algo.map( o, @( l ) { text.split( text.split( l )[0], "/" )[-1].strip( "()-" ); } ), lastTerm ) );
	return ( completions );
}

__printenv( context_ ) {
	return ( "environment: " );
}

__rd( context_ ) {
	return ( "dirs" );
}

__rm( context_ ) {
	return ( "files" );
}

__rmdir( context_ ) {
	return ( "dirs" );
}

__rsync( context_ ) {
	options = [];
	if ( ( "-PHAXpavizn" ∉ context_ ) && ( "-PHAXpaviz" ∉ context_ ) ) {
		options.push( "-PHAXpavizn" );
	}
	for ( o : [ "--delete-after", "--size-only", "--ignore-times", "--numeric-ids" ] ) {
		if ( o ∉ context_ ) {
			options.push( o );
		}
	}
	lastTerm = "";
	if ( size( context_ ) > 1 ) {
		lastTerm = context_[-1];
	}
	return (
		( sct.delimit_singular( sct.filter_by_prefix( options, lastTerm ) ) + sct.delimit_singular( sct.filter_by_prefix( sct.get_hosts(), lastTerm ), ":" ), "files" )
	);
}

__scp( context_ ) {
	lastTerm = "";
	if ( size( context_ ) > 1 ) {
		lastTerm = context_[-1];
	}
	return ( ( sct.delimit_singular( sct.filter_by_prefix( sct.get_hosts(), lastTerm ), ":" ), "files" ) );
}

__setopt( context_ ) {
	options = [ "ignore_filenames", "history_path", "history_max_size", "super_user_paths", "trace", "prefix_commands", "--print" ];
	lastTerm = context_[-1];
	if ( size( context_ ) < 3 ) {
		return ( sct.delimit_singular( sct.filter_by_prefix( options, lastTerm ) ) );
	}
	opt = context_[1];
	switch ( opt ) {
		case ( "trace" ): {
			return ( sct.delimit_singular( sct.filter_by_prefix( [ "on", "off" ], lastTerm ) ) );
		}
		case ( "--print" ): {
			return ( sct.delimit_singular( sct.filter_by_prefix( options, lastTerm ) ) );
		}
	}
	return ( none );
}

__ssh( context_ ) {
	contextSize = size( context_ );
	lastTerm = context_[-1];
	optCount = 0;
	for ( optIdx : algo.range( 1, contextSize - 1 ) ) {
		if ( ! context_[optIdx].starts_with( "-" ) ) {
			break;
		}
		optCount += 1;
	}
	contextSize -= optCount;
	atIdx = lastTerm.find( "@" );
	if ( ( contextSize < 3 ) || ( atIdx >= 0 ) ) {
		if ( atIdx >= 0 ) {
			lastTerm = lastTerm[atIdx + 1:];
		}
		return ( sct.delimit_singular( sct.filter_by_prefix( sct.get_hosts(), lastTerm ) ) );
	}
	return ( sct.forward( context_, {}, 1 + optCount ) );
}

__stat( context_ ) {
	return ( "files" );
}

__su( context_ ) {
	if ( size( context_ ) <= 2 ) {
		lastTerm = context_[-1];
		return ( sct.delimit_singular( sct.filter_by_prefix( sct.get_users(), lastTerm ) ) );
	}
	return ( none );
}

__sudo( context_ ) {
	if ( size( context_ ) <= 2 ) {
		return ( "executables: " );
	}
	return ( sct.forward( context_ ) );
}

__sysctl( context_ ) {
	switches = [ "-a", "-p", "-w" ];
	contextSize = size( context_ );
	if ( contextSize <= 1 ) {
		return ( switches );
	}
	lastTerm = context_[-1];
	if ( contextSize < 2 ) {
		return ( sct.delimit_singular( sct.filter_by_prefix( switches, lastTerm ) ) );
	}
	contextTerm = context_[-2];
	completions = [];
	switch ( contextTerm ) {
		case ( "-p" ): {
			completions = "files";
		} break;
		case ( "-w" ): {
			o = shell.command_output( "/sbin/sysctl", [ "-a", "-N" ] );
			completions = sct.delimit_singular( sct.filter_by_prefix( o, lastTerm ) );
		} break;
		default: {
			completions += sct.delimit_singular( sct.filter_by_prefix( switches, lastTerm ) );
		}
	}
	return ( completions );
}

__systemctl_units() {
	o = shell.command_output( "systemctl", [ "list-unit-files", "--type", "service", "--all", "--plain", "--full", "--no-legend", "--no-pager" ] );
	o = algo.map( o, @( x ) { text.split( x )[0]; } );
	return ( o );
}

__systemctl( context_ ) {
	contextSize = size( context_ );
	lastTerm = context_[-1];
	baseCmds = [ "list-units", "list-unit-files", "show-environment", "daemon-reload" ];
	unitCmds = [ "start", "stop", "reload", "restart", "kill", "status", "show", "enable", "disable", "reenable", "mask", "unmask" ];
	allCmds = baseCmds + unitCmds;
	if ( contextSize < 3 ) {
		return ( sct.delimit_singular( sct.filter_by_prefix( allCmds, lastTerm ) ) );
	}
	cmd = context_[1];
	if ( cmd ∈ unitCmds ) {
		o = sct.file_cached( "systemctl-units", __systemctl_units, sct.always );
		completions = sct.delimit_singular( sct.filter_by_prefix_with_delim( o, lastTerm, "@" ) );
		return ( completions );
	} else {
		if ( '=' ∈ lastTerm ) {
			assignIdx = lastTerm.find( "=" );
			param = lastTerm[:assignIdx];
			types = [ "service", "mount", "swap", "socket", "target", "device", "automount", "timer", "path", "slice", "scope" ];
			states = [
				"dead", "condition", "start-pre", "start", "start-post", "running", "exited", "reload",
				"stop", "stop-watchdog", "stop-sigterm", "stop-sigkill", "stop-post",
				"final-sigterm", "final-sigkill", "failed", "auto-restart", "cleaning",
				"enabled", "enabled-runtime", "linked", "linked-runtime",
				"masked", "masked-runtime", "static", "disabled",
				"indirect", "generated", "transient", "bad"
			];
			items = param == "--type" ? types : states;
			lastTerm = lastTerm[assignIdx + 1:];
			return ( sct.filter_by_prefix( items, lastTerm ) );
		} else {
			return ( sct.filter_by_prefix( [ "--type=", "--state=" ], lastTerm ) );
		}
	}
	return ( none );
}

__tig( context_ ) {
	contextSize = size( context_ );
	lastTerm = context_[-1];
	if ( contextSize < 3 ) {
		baseCmds = sct.delimit_singular( sct.filter_by_prefix( [ "--all", "blame" ], lastTerm ) );
		return ( ( baseCmds + __git_get_branches( lastTerm ), "files" ) );
	}
}

__time( context_ ) {
	if ( size( context_ ) <= 2 ) {
		return ( "executables: " );
	}
	return ( sct.forward( context_ ) );
}

__tmux( context_ ) {
	contextSize = size( context_ );
	lastTerm = context_[-1];
	baseCmds = [
		"attach-session", "has-session", "list-clients", "list-sessions", "new-session"
	];
	if ( contextSize < 3 ) {
		return ( sct.delimit_singular( sct.filter_by_prefix( baseCmds, lastTerm ) ) );
	}
	cmd = context_[1];
	if ( contextSize < 4 ) {
		if ( cmd == "attach-session" ) {
			completions = sct.delimit_singular( sct.filter_by_prefix( ["-t"], lastTerm ) );
			return ( completions );
		}
		return ( none );
	}
	if ( cmd == "attach-session" ) {
		o = shell.command_output( "tmux", [ "list-sessions", "-F", "#{session_name}" ] );
		completions = sct.delimit_singular( sct.filter_by_prefix( o, lastTerm ) );
		return ( completions );
	}
	return ( none );
}

__unalias( context_ ) {
	return ( "aliases: " );
}

__unsetenv( context_ ) {
	return ( "environment: " );
}

__virsh( context_ ) {
	hostCommands = [ "console", "start", "shutdown", "reboot", "reset", "suspend", "resume", "autostart" ];
	commands = hostCommands + [ "list", "vol-list", "help" ];
	lastTerm = context_[-1];
	contextSize = size( context_ );
	if ( contextSize < 3 ) {
		return ( sct.delimit_singular( sct.filter_by_prefix( commands, lastTerm ) ) );
	}
	cmd = context_[-2];
	completions = none;
	if ( cmd ∈ hostCommands ) {
		o = shell.command_output( "virsh", [ "list", "--all", "--name" ] );
		completions = sct.delimit_singular( sct.filter_by_prefix( algo.filter( o, @( x ) { size( x ) > 0; } ), lastTerm ) );
	}
	return ( completions );
}

__watch( context_ ) {
	return ( sct.forward( context_, { "-n": 2 } ) );
}

__whatis( context_ ) {
	return ( ( "commands: ", "su-commands: " ) );
}

__whereis( context_ ) {
	return ( ( "commands: ", "su-commands: " ) );
}

__xargs( context_ ) {
	return ( sct.forward( context_, { "-0": 1, "-I": 2, "-n": 2 } ) );
}

__1exec( context_ ) {
	o = shell.command_output( context_[0], [ "--help", "-v" ] );
	completions = [];
	for ( line : o ) {
		line.strip();
		if ( ¬ line.starts_with( "-" ) ) {
			continue;
		}
		completions += algo.materialize(
			algo.map(
				text.split( line )[:2],
				@( x ) {
					algo.materialize(
						algo.map(
							text.split( x, "=" ),
							string.strip( ~, "[,=" )
						),
						list
					)[0];
				}
			),
			list
		);
	}
	return ( ( sct.delimit_singular( sct.filter_by_prefix( completions, context_[-1] ) ), "files" ) );
}

__configure( context_ ) {
	return ( __1exec( context_ ) );
}

