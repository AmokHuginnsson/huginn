import Algorithms as algo;
import Text as text;
import Shell as shell;

filter_by_prefix( collection_, prefix_, materializeTo_ = list ) {
	f = algo.filter( collection_, @[prefix_]( x ) { x.starts_with( prefix_ ); } );
	if ( materializeTo_ != none ) {
		return ( algo.materialize( f, materializeTo_ ) );
	}
	return ( f );
}

delimit_singular( collection_, by_ = " " ) {
	if ( size( collection_ ) == 1 ) {
		collection_[0] += by_;
	}
	return ( collection_ );
}

__cd( context_ ) {
	return ( "d" );
}

__unalias( context_ ) {
	return ( "a" );
}

__man( context_ ) {
	return ( "c" );
}

__docker( context_ ) {
	return ( context_ );
}

__git( context_ ) {
	baseCmds = [
		"add", "apply", "archive", "bisect", "blame", "branch", "checkout", "cherry-pick", "clone", "commit", "config",
		"diff", "difftool", "fetch", "grep", "help", "init", "log", "ls-files", "merge", "mergetool", "mv", "prune", "pull", "push", "rebase", "remote",
		"reset", "revert", "rm", "show", "show-branch", "stash", "status", "submodule", "tag"
	];
//	print( "context: {}\n".format( context_ ) );
	contextSize = size( context_ );
	if ( contextSize == 0 ) {
		return ( baseCmds );
	}
	lastTerm = context_[-1];
	completions = [];
	if ( contextSize == 1 ) {
		return ( delimit_singular( filter_by_prefix( baseCmds, lastTerm ) ) );
	}
	contextTerm = context_[-2];
	switch ( contextTerm ) {
		case ( "branch" ): {
			branchFlags = [ "--all", "--remotes", "--delete", "-D", "--move", "-avv", "--verbose", "--track", "--no-track" ];
			completions = delimit_singular( filter_by_prefix( branchFlags, lastTerm ) );
		} break;
		case ( "checkout" ): {
			o = shell.command_output( "git", "branch", "-r" );
			completions = delimit_singular( filter_by_prefix( o, lastTerm ) );
		} break;
	}
//	print( "[[[\n{}\n]]]\n".format( completions ) );
	return ( completions );
}

