import Algorithms as algo;
import Operators as oper;
import Text as text;
import RegularExpressions as re;
import FileSystem as fs;
import Introspection as intro;
import Shell as shell;

filter_by_prefix( collection_, prefix_, materializeTo_ = list ) {
	f = algo.filter( collection_, @[prefix_]( x ) { x.starts_with( prefix_ ); } );
	if ( materializeTo_ != none ) {
		return ( algo.materialize( f, materializeTo_ ) );
	}
	return ( f );
}

filter_by_prefix_with_delim( collection_, prefix_, delim_, materializeTo_ = list ) {
	start = prefix_.find_last( delim_ ) + 1;
	f = algo.filter( collection_, @[prefix_]( x ) { x.starts_with( prefix_ ); } );
	m = algo.map( f, @[start]( line_ ) { line_[start:]; } );
	if ( materializeTo_ != none ) {
		return ( algo.materialize( m, materializeTo_ ) );
	}
	return ( m );
}

delimit_singular( collection_, by_ = " " ) {
	if ( size( collection_ ) == 1 ) {
		collection_[0] += by_;
	}
	return ( collection_ );
}

split( lines_ ) {
	return ( algo.reduce( algo.map( lines_, text.split ), oper.add, [] ) );
}

split_by( lines_, by_ ) {
	return ( algo.materialize( algo.map( lines_, @[by_]( x ){ text.split( x, by_ ); } ), list ) );
}

drop( lines_, items_ ) {
	return ( algo.materialize( algo.filter( lines_, @[items_]( line ) { line ∉ items_; } ), list ) );
}

drop_str( lines_, items_ ) {
	for ( line : lines_ ) {
		for ( item : items_ ) {
			line.replace( item, "" );
		}
	}
	return ( lines_ );
}

unique( items_ ) {
	return ( algo.materialize( algo.materialize( items_, set ), list ) );
}

forward( context_, items_ = {} ) {
	i = 1;
	contextSize = size( context_ );
	while ( i < contextSize ) {
		s = items_.get( context_[i], none );
		if ( s == none ) {
			break;
		}
		i += s;
	}
	return ( ( contextSize - i ) > 1 ? complete( context_[i:] ) : "commands: " );
}

complete( context_ ) {
	self = intro.import( "ShellCompletions" );
	command = text.split( context_[0], "/" )[-1].replace( "-", "_" );
	completer = intro.attribute( self, "__" + command );
	return ( completer != none ? completer( context_ ) : none );
}

__apt_cache( context_ ) {
	contextSize = size( context_ );
	lastTerm = context_[-1];
	if ( contextSize < 3 ) {
		return ( delimit_singular( filter_by_prefix( ["search", "show"], lastTerm ) ) );
	}
	if ( context_[1] == "show" ) {
		o = shell.command_output( "dpkg-query", ["-W", "-f", "${Package}\\n"] );
		completions = delimit_singular( filter_by_prefix( o, lastTerm ) );
		return ( completions );
	}
	return ( none );
}

__apt_get( context_ ) {
	contextSize = size( context_ );
	lastTerm = context_[-1];
	baseCmds = ["autoclean", "autoremove", "install", "purge", "remove", "update", "upgrade", "dist-upgrade", "source"];
	if ( contextSize < 3 ) {
		return ( delimit_singular( filter_by_prefix( baseCmds, lastTerm ) ) );
	}
	cmd = context_[1];
	if ( ( cmd == "remove" ) || ( cmd == "purge" ) ) {
		o = shell.command_output( "dpkg-query", ["-W", "-f", "${Package}\\n"] );
		completions = delimit_singular( filter_by_prefix( o, lastTerm ) );
		return ( completions );
	} else if ( ( cmd == "install" ) || ( cmd == "source" ) ) {
		o = shell.command_output( "apt-cache", ["pkgnames"] );
		completions = delimit_singular( filter_by_prefix( o, lastTerm ) );
		return ( completions );
	}
	return ( none );
}

__cd( context_ ) {
	return ( "dirs" );
}

__chown( context_ ) {
	contextSize = size( context_ );
	lastTerm = context_[-1];
	if ( ( contextSize > 2 ) && ( context_[1] == "-R" ) ) {
		contextSize -= 1;
	}
	if ( contextSize > 2 ) {
		return ( "files" );
	}
	by = ":";
	database = "passwd";
	colonIdx = lastTerm.find( ":" );
	pfx = "";
	if ( colonIdx >= 0 ) {
		pfx = lastTerm[:colonIdx + 1];
		lastTerm = lastTerm[colonIdx + 1:];
		by = " ";
		database = "group";
	}
	o = shell.command_output( "getent", [database] );
	completions = delimit_singular( filter_by_prefix( algo.map( split_by( o, ":" ), @[pfx]( x ){ pfx + x[0]; } ), pfx + lastTerm ), by );
	return ( completions );
}

__dd( context_ ) {
	options = { "if=", "of=", "bs=", "count=" };
	contextSize = size( context_ );
	if ( contextSize <= 1 ) {
		return ( algo.materialize( options, list ) );
	}
	lastTerm = context_[-1];
	option = lastTerm[:lastTerm.find( "=" ) + 1];
	if ( ( option == "if=" ) || ( option == "of=" ) ) {
		return ( "prefix:files:" + lastTerm[3:] );
	}
	return ( filter_by_prefix( options, lastTerm ) );
}

__dnf( context_ ) {
	contextSize = size( context_ );
	lastTerm = context_[-1];
	baseCmds = [
		"autoremove", "check-update", "clean", "deplist", "distro-sync", "help",
		"info", "install", "list", "provides", "reinstall", "remove", "search",
		"updateinfo", "upgrade"
	];
	if ( contextSize < 3 ) {
		return ( delimit_singular( filter_by_prefix( baseCmds, lastTerm ) ) );
	}
	cmd = context_[1];
	if ( ( cmd == "remove" ) || ( cmd == "reinstall" ) ) {
		o = shell.command_output( "rpm", ["-qa"] );
		completions = delimit_singular( filter_by_prefix( o, lastTerm ) );
		return ( completions );
	} else if ( ( cmd == "install" ) || ( cmd == "info" ) ) {
		o = shell.command_output( "dnf", ["list", "--cacheonly"] );
		completions = delimit_singular( filter_by_prefix( algo.map( o, @( x ){ text.split( x )[0]; } ), lastTerm ) );
		return ( completions );
	}
	return ( none );
}

__docker( context_ ) {
	baseCmds = [
		"attach", "build", "commit", "config", "container", "cp", "create", "diff", "events", "exec", "export",
		"history", "image", "images", "import", "info", "inspect", "kill", "load", "login", "logout", "logs",
		"network", "node", "pause", "plugin", "port", "ps", "pull", "push", "rename", "restart", "rm", "rmi",
		"run", "save", "search", "secret", "service", "stack", "start", "stats", "stop", "swarm", "system",
		"tag", "top", "trust", "unpause", "update", "version", "volume", "wait"
	];
	contextSize = size( context_ );
	if ( contextSize < 2 ) {
		return ( baseCmds );
	}
	lastTerm = context_[-1];
	return ( delimit_singular( filter_by_prefix( baseCmds, lastTerm ) ) );
}

__dpkg( context_ ) {
	switches = [
		"-L", "-S", "-l", "-P"
	];
	contextSize = size( context_ );
	if ( contextSize <= 1 ) {
		return ( switches );
	}
	lastTerm = context_[-1];
	if ( contextSize < 2 ) {
		return ( delimit_singular( filter_by_prefix( switches, lastTerm ) ) );
	}
	contextTerm = context_[-2];
	completions = [];
	switch ( contextTerm ) {
		case ( "-S" ): {
			completions = "files";
		} break;
		case ( "-P" ): { /* fall-through */ }
		case ( "-L" ): {
			o = shell.command_output( "dpkg-query", ["-W", "-f", "${Package}\\n"] );
			completions = delimit_singular( filter_by_prefix( o, lastTerm ) );
		} break;
		case ( "-l" ): {
			if ( context_[-1] == "" ) {
				completions = [ "'**'" ];
			}
		} break;
		case ( "-i" ): {
			return ( "files" );
		} break;
		default: {
			completions += delimit_singular( filter_by_prefix( switches, lastTerm ) );
		}
	}
	return ( completions );
}

__env( context_ ) {
	contextSize = size( context_ ) - 1;
	i = 1;
	while ( i < contextSize ) {
		token = context_[i];
		if ( ( size( token ) > 0 ) && ( token.find( "=" ) < 0 ) ) {
			break;
		}
		i += 1;
	}
	completions = i < contextSize ? complete( context_[i:] ) : ( "environment", "executables: " );
	return ( completions );
}

__exec( context_ ) {
	if ( size( context_ ) <= 2 ) {
		return ( "executables: " );
	}
	return ( forward( context_ ) );
}

__file( context_ ) {
	return ( "files" );
}

__find( context_ ) {
	contextSize = size( context_ );
	if ( contextSize < 3 ) {
		return ( "dirs" );
	}
	completions = delimit_singular( filter_by_prefix( ["-name", "-iname", "-path", "-print0", "-perm"], context_[-1] ) );
	if ( ( size( completions ) == 1 ) && ( ( completions[0] == "-iname " ) || ( completions[0] == "-name " ) ) ) {
		completions[0] += "'**'";
	}
	return ( completions );
}

__git( context_ ) {
	baseCmds = [
		"add", "apply", "archive", "bisect", "blame", "branch", "checkout", "cherry-pick", "clone", "commit", "config",
		"diff", "difftool", "fetch", "grep", "help", "init", "log", "ls-files", "merge", "mergetool", "mv", "prune", "pull",
		"push", "rebase", "reflog", "remote", "reset", "revert", "rm", "show", "show-branch", "stash", "status", "submodule", "tag"
	];
	baseCmds += algo.materialize( algo.map( shell.command_output( "git", ["config", "--name-only", "--get-regexp", "alias"] ), @( x ){ x[6:]; } ), list );
	baseFlags = ["-c", "-C", "--bare"];
	contextSize = size( context_ );
	if ( contextSize <= 1 ) {
		return ( baseCmds );
	}
	lastTerm = context_[-1];
	completions = [];
	if (
		( contextSize == 2 )
		|| ( ( contextSize >= 3 ) && ( context_[-2] == "--bare" ) )
		|| ( ( contextSize >= 4 ) && ( ( context_[-3] == "-C" ) || ( context_[-3] == "-c" ) ) )
	) {
		return ( delimit_singular( filter_by_prefix( algo.chain( baseCmds, baseFlags ), lastTerm ) ) );
	}
	contextTerm = context_[-2];
	i = 1;
	while ( i < contextSize ) {
		token = context_[i];
		if ( token == "--bare" ) {
		} else if ( ( i < contextSize ) && ( ( token == "-C" ) || ( token == "-c" ) ) ) {
			i += 1;
		} else {
			contextTerm = token;
			break;
		}
		i += 1;
	}
	flagTermIdx = -2;
	flagTerm = context_[flagTermIdx];
	if ( ! flagTerm.starts_with( "-" ) && ( contextSize > 3 ) && context_[-3].starts_with( "-" ) ) {
		flagTermIdx = -3;
		flagTerm = context_[flagTermIdx];
	}
	//print( "\ncontext: [{}]\ncontextSize = [{}]\ncontextTerm = [{}]\nflagTerm = [{}]\nlastTerm = [{}]\n".format( context_, contextSize, contextTerm, flagTerm, lastTerm ) );
	delimitSingular = " ";
	switch ( contextTerm ) {
		case ( "help" ): {
			completions = delimit_singular( filter_by_prefix( baseCmds, lastTerm ) );
		} break;
		case ( "add" ): {
			o = shell.command_output( "git", ["ls-files", "--exclude-standard", "-o", "-m"] );
			completions = delimit_singular( filter_by_prefix_with_delim( o, lastTerm, "/" ) );
		} break;
		case ( "branch" ): {
			if ( ( flagTerm == "--delete" ) || ( flagTerm == "-D" ) || ( flagTerm == "--move" ) || ( flagTerm == "--copy" ) ) {
				o = shell.command_output( "git", ["branch", "-a"] );
				completions += delimit_singular( filter_by_prefix_with_delim( drop_str( drop( split( o ), [ "*", "->" ] ), ["remotes/"] ), lastTerm, "/" ) );
			} else {
				branchFlags = [ "--all", "--remotes", "--delete", "-D", "--move", "--copy", "-avv", "--verbose", "--track", "--no-track", "--set-upstream", "--force" ];
				completions += delimit_singular( filter_by_prefix( branchFlags, lastTerm ) );
			}
		} break;
		case ( "checkout" ): {
			if ( ( flagTerm != "-b" ) && ( flagTerm != "-B" ) ) {
				checkoutFlags = [ "-b", "-B", "--force", "--track", "--no-track" ];
				completions = delimit_singular( filter_by_prefix( checkoutFlags, lastTerm ) );
				o = shell.command_output( "git", ["branch", "-a"] );
				completions += delimit_singular( filter_by_prefix_with_delim( drop_str( drop( split( o ), [ "*", "->" ] ), ["remotes/"] ), lastTerm, "/" ) );
				o = shell.command_output( "git", ["tag"] );
				completions += delimit_singular( filter_by_prefix_with_delim( o, lastTerm, "/" ) );
				o = shell.command_output( "git", ["ls-files", "-m"] );
				completions += delimit_singular( filter_by_prefix_with_delim( o, lastTerm, "/" ) );
			} else if ( contextSize > 4 ) {
				o = shell.command_output( "git", ["branch", "-a"] );
				completions = delimit_singular( filter_by_prefix_with_delim( drop_str( drop( split( o ), [ "*", "->" ] ), ["remotes/"] ), lastTerm, "/" ) );
			}
		} break;
		case ( "cherry-pick" ): {
			cherrypickFlags = [ "--abort", "--continue", "--edit", "--no-commit", "--quit" ];
			completions = delimit_singular( filter_by_prefix( cherrypickFlags, lastTerm ) );
			o = shell.command_output( "git", ["branch", "-a"] );
			completions += delimit_singular( filter_by_prefix_with_delim( drop_str( drop( split( o ), [ "*", "->" ] ), ["remotes/"] ), lastTerm, "/" ) );
		} break;
		case ( "-C" ): {
			return ( "dirs" );
		} break;
		case ( "commit" ): {
			if ( lastTerm == "-m" ) {
				completions = ["-m ''"];
			} else if ( ( flagTerm == "-m" ) && ( flagTermIdx == -2 ) ) {
				completions = ["''"];
			} else {
				commitFlags = [ "--amend", "-a", "--no-edit", "-m", "-p" ];
				completions = delimit_singular( filter_by_prefix( commitFlags, lastTerm ) );
				o = shell.command_output( "git", ["ls-files", "--exclude-standard", "-o", "-m"] );
				completions += delimit_singular( filter_by_prefix_with_delim( o, lastTerm, "/" ) );
			}
		} break;
		case ( "-c" ): { delimitSingular = "="; }
		case ( "config" ): {
			o = shell.command_output( "git", ["config", "-l", "--name-only"] );
			completions = delimit_singular( filter_by_prefix( o, lastTerm ), delimitSingular );
		} break;
		case ( "difftool" ): {
			difftoolFlags = [ "-d", "-t" ];
			completions = delimit_singular( filter_by_prefix( difftoolFlags, lastTerm ) );
		} break;
		case ( "fetch" ): {
			fetchFlags = [ "--all", "--prune", "--prune-tags", "--no-tags", "--tags" ];
			completions = delimit_singular( filter_by_prefix( fetchFlags, lastTerm ) );
			o = shell.command_output( "git", ["remote"] );
			completions += delimit_singular( filter_by_prefix( o, lastTerm ) );
		} break;
		case ( "log" ): {
			logFlags = [ "--oneline", "--pretty" ];
			completions = delimit_singular( filter_by_prefix( logFlags, lastTerm ) );
			logFlags = [ "--format=email", "--format=short", "--format=medium", "--format=fuller", "--date=iso", "--date=rfc", "--date=unix" ];
			completions += delimit_singular( filter_by_prefix_with_delim( logFlags, lastTerm, "=" ) );
		} break;
		case ( "merge" ): {
			mergeFlags = [ "--abort", "--continue", "--quit", "--ff" ];
			completions = delimit_singular( filter_by_prefix( mergeFlags, lastTerm ) );
			o = shell.command_output( "git", ["branch", "-a"] );
			completions += delimit_singular( filter_by_prefix_with_delim( drop_str( drop( split( o ), [ "*", "->" ] ), ["remotes/"] ), lastTerm, "/" ) );
		} break;
		case ( "pull" ): {
			pullFlags = [ "--all", "--rebase", "--tags" ];
			completions = delimit_singular( filter_by_prefix( pullFlags, lastTerm ) );
			o = shell.command_output( "git", ["branch", "-a"] );
			completions += delimit_singular( filter_by_prefix_with_delim( drop_str( drop( split( o ), [ "*", "->" ] ), ["remotes/"] ), lastTerm, "/" ) );
			o = shell.command_output( "git", ["remote"] );
			completions += delimit_singular( filter_by_prefix( split( o ), lastTerm ) );
		} break;
		case ( "push" ): {
			pushFlags = [ "--all", "--prune", "--mirror", "--tags", "--delete", "--force", "--set-upstream" ];
			completions = delimit_singular( filter_by_prefix( pushFlags, lastTerm ) );
			o = shell.command_output( "git", ["branch", "-a"] );
			completions += delimit_singular( filter_by_prefix_with_delim( drop_str( drop( split( o ), [ "*", "->" ] ), ["remotes/"] ), lastTerm, "/" ) );
		} break;
		case ( "rebase" ): {
			rebaseFlags = [ "--abort", "--continue", "--interactive", "--skip" ];
			completions = delimit_singular( filter_by_prefix( rebaseFlags, lastTerm ) );
			o = shell.command_output( "git", ["branch", "-a"] );
			completions += delimit_singular( filter_by_prefix_with_delim( drop_str( drop( split( o ), [ "*", "->" ] ), ["remotes/"] ), lastTerm, "/" ) );
		} break;
		case ( "remote" ): {
			remoteCommands = [ "-v", "add", "rename", "rm", "prune", "set-head", "set-branch", "set-url" ];
			completions = delimit_singular( filter_by_prefix( remoteCommands, lastTerm ) );
		} break;
		case ( "reset" ): {
			resetFlags = [ "--hard ", "--soft ", "--keep ", "--mixed ", "--merge ", "HEAD~" ];
			completions = delimit_singular( filter_by_prefix( resetFlags, lastTerm ), "" );
			o = shell.command_output( "git", ["branch", "-a"] );
			completions += delimit_singular( filter_by_prefix_with_delim( drop_str( drop( split( o ), [ "*", "->" ] ), ["remotes/"] ), lastTerm, "/" ) );
		} break;
		case ( "stash" ): {
			stashCommands = [ "list", "show", "drop", "pop", "apply", "branch", "save", "clear", "create" ];
			completions = delimit_singular( filter_by_prefix( stashCommands, lastTerm ) );
		} break;
		case ( "status" ): {
			statusFlags = [ "--branch", "--ignored", "--long", "--porcelain", "--short" ];
			completions = delimit_singular( filter_by_prefix( statusFlags, lastTerm ) );
		} break;
		case ( "tag" ): {
			if ( ( flagTerm == "--delete" ) || ( flagTerm == "-d" ) ) {
				o = shell.command_output( "git", ["tag", "--list"] );
				completions += delimit_singular( filter_by_prefix_with_delim( o, lastTerm, "/" ) );
			} else if ( ( flagTerm == "--file" ) || ( flagTerm == "-F" ) ) {
				completions = "files";
			} else if ( lastTerm == "-m" ) {
				completions = ["-m ''"];
			} else if ( flagTerm == "-m" ) {
				completions = ["''"];
			} else {
				tagFlags = [ "--delete", "-d", "-a", "--force", "--list", "--file" ];
				completions += delimit_singular( filter_by_prefix( tagFlags, lastTerm ) );
			}
		} break;
		default: {
			return ( "files" );
		}
	}
//	print( "[[[\n{}\n]]]\n".format( completions ) );
	return ( completions );
}

__gpg( context_ ) {
	switches = [
		"--armor", "--bzip2-compress-level", "--card-edit", "--card-status", "--change-pin", "--check-sigs", "--check-trustdb",
		"--clearsign", "--compress-level", "--dearmor", "--decrypt", "--decrypt-files", "--delete-key", "--delete-secret-and-public-key",
		"--delete-secret-key", "--desig-revoke", "--detach-sign", "--dump-options", "--edit-key", "--enarmor", "--encrypt", "--encrypt-files",
		"--export", "--export-options", "--export-ownertrust", "--export-secret-keys", "--export-secret-subkeys", "--fast-import",
		"--fetch-keys", "--fingerprint", "--gen-key", "--gen-prime", "--gen-random", "--gen-revoke", "--import", "--import-options",
		"--import-ownertrust", "--interactive", "--keyring", "--keyserver-options", "--list-keys", "--list-packets", "--list-public-keys",
		"--list-secret-keys", "--list-sigs", "--lsign-key", "--multifile", "--no-armor", "--no-textmode", "--output", "--primary-keyring",
		"--print-md", "--print-mds", "--rebuild-keydb-caches", "--recv-keys", "--refresh-keys", "--search-keys", "--secret-keyring",
		"--send-keys", "--sign", "--sign-key", "--textmode", "--trustdb-name", "--update-trustdb", "--verify", "--verify-files",
		"--with-fingerprint"
	];
	lastTerm = "";
	contextSize = size( context_ );
	if ( contextSize <= 1 ) {
		return ( switches );
	}
	lastTerm = context_[-1];
	if ( contextSize < 2 ) {
		return ( delimit_singular( filter_by_prefix( switches, lastTerm ) ) );
	}
	contextTerm = context_[-2];
	completions = [];
	switch ( contextTerm ) {
		case ( "--import-options" ): {
			importOptions = ["import-local-sigs", "merge-only", "import-clean", "import-minimal"];
			completions += delimit_singular( filter_by_prefix( importOptions, lastTerm ) );
		} break;
		case ( "--export-options" ): {
			exportOptions = ["export-local-sigs", "export-attributes", "export-sensitive-revkeys", "export-reset-subkey-passwd", "export-clean export-minimal"];
			completions += delimit_singular( filter_by_prefix( exportOptions, lastTerm ) );
		} break;
		case ( "--edit-key" ): { /* fall-through */ }
		case ( "--send-keys" ): {
			o = shell.command_output( "gpg", ["-k"] );
			completions += delimit_singular(
				filter_by_prefix_with_delim(
					algo.map( shell.grep( o, "uid.*@" ), @( x ){ text.split( x )[-1].strip( "<>" ); } ),
					lastTerm,
					"@"
				)
			);
		} break;
		case ( "-c" ): { /* fall-through */ }
		case ( "--decrypt" ): {
			completions = "files";
		} break;
		default: {
			completions += delimit_singular( filter_by_prefix( switches, lastTerm ) );
		}
	}
	return ( completions );
}

__help( context_ ) {
	topics = [
		"alias", "bg", "bindkey", "cd", "dirs", "eval", "exec", "exit",
		"fg", "help", "history", "jobs", "rehash", "setenv", "setopt",
		"source", "unalias", "unsetenv", "topics", "history_path", "history_max_size",
		"ignore_filenames", "super_user_paths"
	];
	lastTerm = "";
	if ( size( context_ ) > 1 ) {
		lastTerm = context_[-1];
	}
	return ( delimit_singular( filter_by_prefix( topics, lastTerm ) ) );
}

__history( context_ ) {
	options = [ "--indexed", "--no-color", "--help" ];
	lastTerm = "";
	if ( size( context_ ) > 1 ) {
		lastTerm = context_[-1];
	}
	return ( delimit_singular( filter_by_prefix( options, lastTerm ) ) );
}

__hgnsh( context_ ) {
	return ( __huginn( context_ ) );
}

__huginn( context_ ) {
	options = [
		"--auto-split",
		"--alias-imports",
		"--be-sloppy",
		"--color-scheme",
		"--command",
		"--dump-state",
		"--embedded",
		"--field-separator",
		"--gen-docs",
		"--help",
		"--history-file",
		"--in-place",
		"--jupyter",
		"--chomp",
		"--lint",
		"--log-path",
		"--module-path",
		"--sed-n",
		"--native-lines",
		"--no-argv",
		"--no-color",
		"--no-default-imports",
		"--no-default-init",
		"--optimize",
		"--sed",
		"--quiet",
		"--rapid-start",
		"--shell",
		"--session",
		"--session-directory",
		"--tags",
		"--verbose",
		"--version",
		"--dump-configuration"
	];
	lastTerm = "";
	if ( size( context_ ) > 1 ) {
		lastTerm = context_[-1];
	}
	return ( ( filter_by_prefix( options, lastTerm ), "files" ) );
}

__make( context_ ) {
	makefileNames = [ "BSDmakefile", "GNUmakefile", "Makefile", "makefile", "_aux/mk/master.mk" ];
	contextSize = size( context_ );
	contextTerm = "";
	if ( contextSize > 2 ) {
		contextTerm = context_[-2];
	}
	if ( contextTerm == "-f" ) {
		return ( "files" );
	}
	if ( contextTerm == "-C" ) {
		return ( "dirs" );
	}
	lastTerm = "";
	if ( contextSize > 0 ) {
		lastTerm = context_[-1];
	}
	completions = [];
	for ( makefileName : makefileNames ) {
		try {
			makefile = fs.open( makefileName, fs.OPEN_MODE.READ );
			completions += delimit_singular( filter_by_prefix( drop( split( algo.filter( makefile, @( l ) { l.find( "PHONY" ) >= 0; } ) ), [ ".PHONY:" ] ), lastTerm ) );
		} catch ( FileSystemException e ) {
		}
	}
	if ( ( lastTerm == "" ) || ( lastTerm == "-" ) ) {
		completions.push( "-f" ).push( "-C" );
	} else if ( lastTerm == "-f" ) {
		completions.push( "-f " );
	} else if ( lastTerm == "-C" ) {
		completions.push( "-C " );
	}
	return ( completions );
}

__man( context_ ) {
	return ( ( "commands: ", "su-commands: " ) );
}

__pkg( context_ ) {
	contextSize = size( context_ );
	lastTerm = context_[-1];
	baseCmds = [
		"add", "autoremove", "check", "clean", "delete", "fetch",
		"help", "info", "install", "query", "remove", "search",
		"update", "updating", "upgrade", "which"
	];
	if ( contextSize < 3 ) {
		return ( delimit_singular( filter_by_prefix( baseCmds, lastTerm ) ) );
	}
	cmd = context_[1];
	if ( ( cmd == "delete" ) || ( cmd == "remove" ) ) {
		o = shell.command_output( "/usr/sbin/pkg", ["info", "-a"] );
		completions = delimit_singular( filter_by_prefix( algo.map( o, @( x ){ text.split( x )[0]; } ), lastTerm ) );
		return ( completions );
	} else if ( ( cmd == "install" ) || ( cmd == "info" ) ) {
		o = shell.command_output( "/usr/sbin/pkg", ["search", "."] );
		completions = delimit_singular( filter_by_prefix( algo.map( o, @( x ){ text.split( x )[0]; } ), lastTerm ) );
		return ( completions );
	} else if ( ( cmd == "add" ) || ( cmd == "which" ) ) {
		return ( "files" );
	}
	return ( none );
}

__pkill( context_ ) {
	contextSize = size( context_ );
	lastTerm = "";
	if ( contextSize > 1 ) {
		lastTerm = context_[-1];
	}
	o = shell.command_output( "ps", ["hx", "-o", "args"] );
	completions = delimit_singular( filter_by_prefix( algo.map( o, @( l ){ text.split( text.split( l )[0], "/" )[-1].strip( "()-" ); } ), lastTerm ) );
	return ( completions );
}

__printenv( context_ ) {
	return ( "environment: " );
}

__rsync( context_ ) {
	options = [];
	if ( ( "-PHAXpavizn" ∉ context_ ) && ( "-PHAXpavizn" ∉ context_ ) ) {
		options.push( "-PHAXpavizn" );
	}
	if ( "--delete-after" ∉ context_ ) {
		options.push( "--delete-after" );
	}
	lastTerm = "";
	if ( size( context_ ) > 1 ) {
		lastTerm = context_[-1];
	}
	return ( ( delimit_singular( filter_by_prefix( options, lastTerm ) ), "files" ) );
}

__setopt( context_ ) {
	options = ["ignore_filenames", "history_path", "history_max_size", "super_user_paths"];
	lastTerm = "";
	if ( size( context_ ) > 1 ) {
		lastTerm = context_[-1];
	}
	return ( delimit_singular( filter_by_prefix( options, lastTerm ) ) );
}

__stat( context_ ) {
	return ( "files" );
}

__sudo( context_ ) {
	if ( size( context_ ) <= 2 ) {
		return ( "executables: " );
	}
	return ( forward( context_ ) );
}

__sysctl( context_ ) {
	switches = ["-a", "-p", "-w"];
	contextSize = size( context_ );
	if ( contextSize <= 1 ) {
		return ( switches );
	}
	lastTerm = context_[-1];
	if ( contextSize < 2 ) {
		return ( delimit_singular( filter_by_prefix( switches, lastTerm ) ) );
	}
	contextTerm = context_[-2];
	completions = [];
	switch ( contextTerm ) {
		case ( "-p" ): {
			completions = "files";
		} break;
		case ( "-w" ): {
			o = shell.command_output( "/sbin/sysctl", ["-a", "-N"] );
			completions = delimit_singular( filter_by_prefix( o, lastTerm ) );
		} break;
		default: {
			completions += delimit_singular( filter_by_prefix( switches, lastTerm ) );
		}
	}
	return ( completions );
}

__systemctl( context_ ) {
	contextSize = size( context_ );
	lastTerm = context_[-1];
	baseCmds = ["list-units", "show-environment"];
	unitCmds = ["start", "stop", "reload", "restart", "kill", "status", "show", "enable", "disable", "reenable", "mask", "unmask"];
	allCmds = baseCmds + unitCmds;
	if ( contextSize < 3 ) {
		return ( delimit_singular( filter_by_prefix( allCmds, lastTerm ) ) );
	}
	cmd = context_[1];
	if ( cmd ∈ unitCmds ) {
		o = shell.command_output( "systemctl", ["list-units", "--type", "service", "--all", "--plain", "--full", "--no-legend", "--no-pager"] );
		completions = delimit_singular( filter_by_prefix_with_delim( algo.map( o, @( x ){ text.split( x )[0]; } ), lastTerm, "@" ) );
		return ( completions );
	}
	return ( none );
}

__unalias( context_ ) {
	return ( "aliases: " );
}

__unsetenv( context_ ) {
	return ( "environment: " );
}

__virsh( context_ ) {
	hostCommands = ["start", "shutdown", "reboot", "reset", "suspend", "resume"];
	commands = hostCommands + ["list"];
	lastTerm = context_[-1];
	contextSize = size( context_ );
	if ( contextSize < 3 ) {
		return ( delimit_singular( filter_by_prefix( commands, lastTerm ) ) );
	}
	cmd = context_[-2];
	completions = none;
	if ( cmd ∈ hostCommands ) {
		o = shell.command_output( "virsh", ["list", "--all", "--name"] );
		completions = delimit_singular( filter_by_prefix( algo.filter( o, @( x ) { size( x ) > 0; } ), lastTerm ) );
	}
	return ( completions );
}

__watch( context_ ) {
	return ( forward( context_, { "-n": 2 } ) );
}

__whatis( context_ ) {
	return ( ( "commands: ", "su-commands: " ) );
}

__whereis( context_ ) {
	return ( ( "commands: ", "su-commands: " ) );
}

__xargs( context_ ) {
	return ( forward( context_, { "-0": 1, "-I": 2, "-n": 2 } ) );
}

__1exec( context_ ) {
	o = shell.command_output( context_[0], ["--help"] );
	completions = [];
	for ( line : o ) {
		line.strip();
		if ( line.starts_with( "-" ) ) {
			completions.push( text.split( text.split( line )[0].strip( "," ), "=" )[0] );
		}
	}
	return ( delimit_singular( filter_by_prefix( completions, context_[-1] ) ) );
}

__configure( context_ ) {
	return ( __1exec( context_ ) );
}

