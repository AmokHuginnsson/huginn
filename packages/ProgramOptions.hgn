/* Program options handler. */

import Algorithms as algo;
import Text as text;
import OperatingSystem as os;

/* Requirements type for option value. */
enum VALUE_REQUIREMENT {
	/* Option value is required. */
	REQUIRED,
	/* Option value is optional. */
	OPTIONAL,
	/* Option does not accept a value. */
	NONE
}

/* Program option description. */
class Option {
	_short = none;
	_long = none;
	_requement = none;
	_conversion = none;
	_valueName = none;
	_help = none;
	_defaultValue = none;
	constructor( name, requirement, help, conversion, valueName, defaultValue ) {
		assert( type( name ) == string, "Option name must be a `string` object." );
		assert( type( requirement ) == type( VALUE_REQUIREMENT.REQUIRED ), "Value requirement must be a VALUE_REQUIREMENT type." );
		assert( type( help ) == string, "Help must be a `string` object." );
		assert( type( conversion ) == type( type ), "Option value type must be a `callable`." );
		assert(
			( ( requirement == VALUE_REQUIREMENT.NONE ) && ( valueName == none ) ) || ( type( valueName ) == string ),
			"Option value name must be a `string` object."
		);
		assert( ( defaultValue == none ) || ( type( defaultValue ) == conversion ), "Type of default value must be congruent with option value type." );
		n = text.split( name, "," );
		assert( size( n ) < 3, "Option name can have at most two forms." );
		if ( size( n ) == 1 ) {
			assert( size( n[0] ) > 0, "AnÂ option reuires a name." );
			if ( size( n[0] ) == 1 ) {
				_short = n[0][0];
			} else {
				_long = n[0];
			}
		} else {
			assert(
				( ( size( n[0] ) == 1 ) && ( size( n[1] ) > 1 ) ) || ( ( size( n[1] ) == 1 ) && ( size( n[0] ) > 1 ) ),
				"Using two option name forms, one of them must be short and another one must be long."
			);
			if ( size( n[0] ) == 1 ) {
				_short = n[0][0];
				_long = n[1];
			} else {
				_short = n[1][0];
				_long = n[0];
			}
		}
		_conversion = conversion;
		_requement = requirement;
		_valueName = valueName;
		_help = help;
		_defaultValue = defaultValue;
	}
	help_str_helper() {
		s = "";
		if ( _requement != VALUE_REQUIREMENT.NONE ) {
			fmt = _requement == VALUE_REQUIREMENT.REQUIRED ? "{}{}" : ( _long != none ? "[{}{}]" : "{}[{}]" );
			s = fmt.format( _long != none ? "=" : " ", _valueName != none ? _valueName : "val" );
		}
		return ( s );
	}
	help_len_helper() {
		l = size( help_str_helper() );
		l += ( _long != none ? size( _long ) : 0 );
		return ( l );
	}
	to_string() {
		return ( "Option({}, {}, {}, {}, {}, {}, {})".format( _short, _long, _requement, _conversion, _valueName, _help, _defaultValue ) );
	}
}

/* Program options handler. */
class Handler {
	_name = none;
	_doc = none;
	_options = [];
	__verify_option( opt_ ) {
		for ( o : _options ) {
			assert( ( opt_._short == none ) || ( opt_._short != o._short ), "Short form `-{}` already used by other option.".format( opt_._short ) );
			assert( ( opt_._long == none ) || ( opt_._long != o._long ), "Long form `--{}` already used by other option.".format( opt_._long ) );
		}
	}
	constructor( name_, doc_ ) {
		_name = name_;
		_doc = doc_;
	}
	/* Add option description to the handler. */
	add_option( name, requirement, help, conversion = type( none ), valueName = none, defaultValue = none ) {
		opt = Option( name, requirement, help, conversion, valueName, defaultValue );
		__verify_option( opt );
		_options.push( opt );
	}
	/* Parse command line options. */
	command_line( argv_ ) {
		argc = size( argv_ );
		options = {};
		invalid = 0;
		nonOption = 1;
		i = 1;
		while ( i < argc ) {
			arg = argv_[i];
			if ( arg.starts_with( "--" ) ) {
				arg = arg[2:];
				argNameEnd = arg.find( "=" );
				value = none;
				if ( argNameEnd >= 0 ) {
					value = arg[argNameEnd + 1:];
					arg = arg[:argNameEnd];
				}
				opt = algo.iterator( algo.filter( _options, @[arg]( o ){ o._long == arg; } ) );
				if ( opt.is_valid() ) {
					opt = opt.value();
					if ( ( opt._requement == VALUE_REQUIREMENT.REQUIRED ) && ( argNameEnd == -1 ) ) {
						i += 1;
						if ( i < argc ) {
							value = argv_[i];
						} else {
							invalid += 1;
							os.stderr().write_line( "{}: Option: `--{}` requres an argument.\n".format( argv_[0], arg ) );
						}
					}
					if ( value != none ) {
						options[opt._long] = opt._conversion( value );
					}
				} else {
					invalid += 1;
					os.stderr().write_line( "{}: Unrecognized option: `--{}`\n".format( argv_[0], arg ) );
				}
			} else if ( arg.starts_with( "-" ) ) {
				arg = arg[1:];
				value = none;
				argLen = size( arg );
				k = 0;
				while ( k < argLen ) {
					a = arg[k];
					opt = algo.iterator( algo.filter( _options, @[a]( o ){ o._short == a; } ) );
					if ( opt.is_valid() ) {
						opt = opt.value();
						if ( ( opt._requement == VALUE_REQUIREMENT.REQUIRED ) || ( opt._requement == VALUE_REQUIREMENT.OPTIONAL ) ) {
							value = arg[k + 1:];
							k += size( value );
						}
						if ( ( opt._requement == VALUE_REQUIREMENT.REQUIRED ) && ( ( value == none ) || ( size( value ) == 0 ) ) ) {
							i += 1;
							if ( i < argc ) {
								value = argv_[i];
							} else {
								k += 1;
								invalid += 1;
								os.stderr().write_line( "{}: Option: `-{}` requres an argument.\n".format( argv_[0], a ) );
								continue;
							}
						}
						if ( value != none ) {
							options[opt._long] = opt._conversion( value );
						}
					} else {
						invalid += 1;
						os.stderr().write_line( "{}: Unrecognized option: `-{}`\n".format( argv_[0], a ) );
					}
					k += 1;
				}
			} else {
				argv_ = argv_[:i] + argv_[i + 1:] + [argv_[i]];
				nonOption += 1;
				i -= 1;
				argc -= 1;
			}
			i += 1;
		}
		return ( ( options, argv_[argc:] ) );
	}
	help_string() {
		doc = "Usage: {0} [OPTION]... [FILE]...\n{0} - {1}\n".format( _name, _doc );
		doc += "\n";
		doc += "Options:\n";
		maxLen = 0;
		hasShort = false;
		for ( o : _options ) {
			l = o.help_len_helper();
			if ( ( o._long != none ) && ( l > maxLen ) ) {
				maxLen = l;
			}
			if ( o._short != none ) {
				hasShort = true;
			}
		}
		for ( o : _options ) {
			s = o.help_str_helper();
			l = o.help_len_helper();
			if ( ( o._short != none ) && ( o._long != none ) ) {
				fmt = "  -{{}}, --{{}}{{}}  {{:{}s}}{{}}\n".format( maxLen - l );
				doc += fmt.format( o._short, o._long, s, "", o._help );
			} else if ( o._long != none ) {
				fmt = "  {}--{{}}{{}}  {{:{}s}}{{}}\n".format( hasShort ? "    " : "", maxLen - l );
				doc += fmt.format( o._long, s, "", o._help );
			} else {
				fmt = "  -{{}}{{}}  {{:{}s}}{{}}\n".format( maxLen + 4 - l );
				doc += fmt.format( o._short, s, "", o._help );
			}
		}
		doc += "\nAll long form options can be used in program configuration file: {}rc.".format( _name );
		return ( doc );
	}
	to_string() {
		return ( "{}".format( _options ) );
	}
}

